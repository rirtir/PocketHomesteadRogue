<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Pocket Homestead — Main Map (Prototype)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0b0b;color:#ddd;font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP";}
  #gameWrap{display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:8px;box-sizing:border-box;}
  .hud{width:100%;max-width:480px;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;}
  .small{font-size:12px;color:#bbb}
  .canvasWrap{width:100%;max-width:480px;position:relative;display:flex;justify-content:center;}
  canvas{background:#132; image-rendering: pixelated; border-radius:6px; display:block; width:100%; height: calc(100vh - 180px); max-height:640px; touch-action:none;}
  /* joystick + buttons */
  .joystickBase{position:absolute;left:12px;bottom:12px;width:140px;height:140px;border-radius:50%;background:rgba(20,20,20,0.55);border:2px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;z-index:30;touch-action:none}
  .joystickGuide{position:absolute;width:70px;height:70px;border-radius:50%;background:rgba(255,255,255,0.02);border:1px dashed rgba(255,255,255,0.02)}
  .joystickKnob{position:absolute;width:46px;height:46px;border-radius:50%;background:rgba(255,255,255,0.12);border:1px solid rgba(255,255,255,0.12);transform:translate(-50%,-50%);left:50%;top:50%}
  .confirmBtn{position:absolute;right:12px;bottom:12px;min-width:72px;height:72px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.08));border:2px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-weight:600;z-index:30;touch-action:manipulation}
  .invBtn{position:absolute;right:12px;bottom:96px;min-width:56px;height:48px;border-radius:10px;background:rgba(30,30,30,0.6);border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;font-size:13px;z-index:30;touch-action:manipulation}
  .uiLabel{position:absolute;left:12px;bottom:162px;font-size:12px;color:#cfcfcf;z-index:29}
  /* inventory modal */
  .invModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:90%;max-width:380px;background:#0f0f12;border:1px solid #222;padding:12px;border-radius:8px;box-shadow:0 12px 30px rgba(0,0,0,0.7);z-index:80;display:none}
  .invGrid{display:flex;flex-wrap:wrap;gap:8px}
  .invSlot{width:64px;height:64px;background:#151515;border-radius:6px;display:flex;align-items:center;justify-content:center;color:#ddd}
  .closeInv{margin-top:8px;padding:8px;border-radius:6px;background:#222;border:1px solid #333;color:#eee}
  @media (max-width:420px){ .joystickBase{width:110px;height:110px} .joystickKnob{width:40px;height:40px} .confirmBtn{width:64px;height:64px} .invBtn{right:12px;bottom:88px} }
</style>
</head>
<body>
  <div id="gameWrap">
    <div class="hud">
      <div><div class="small">HP <span id="hpText">30/30</span></div><div class="small">Runs: <span id="runCount">0</span></div></div>
      <div style="font-size:12px;color:#bbb">Main Map</div>
    </div>

    <div class="canvasWrap">
      <canvas id="c" width="144" height="256"></canvas>

      <!-- joystick / UI -->
      <div class="joystickBase" id="joystickBase">
        <div class="joystickGuide"></div>
        <div class="joystickKnob" id="joystickKnob"></div>
      </div>
      <div class="uiLabel">左で移動</div>

      <button class="confirmBtn" id="confirmBtn">Confirm</button>
      <button class="invBtn" id="invBtn">Inventory</button>
    </div>

    <!-- inventory modal -->
    <div class="invModal" id="invModal" role="dialog" aria-hidden="true">
      <h3 style="margin:0 0 8px 0;color:#fff">Inventory</h3>
      <div class="invGrid" id="invGrid"></div>
      <button class="closeInv" id="closeInv">Close</button>
    </div>

  </div>

<script>
/* Main map prototype:
 - Loads assets/map.json
 - Draws regions (2x2 / 3x3 rectangles) on a small grid
 - Player moves using joystick (same as prior logic)
 - Confirm: if player adjacent to any region tile, calls enterRegion(region)
 - Inventory button toggles modal
*/

// canvas / constants
const TILE = 16;
const VIEW_W_TILES = 9;
const VIEW_H_TILES = 9; // use square map for main screen
const CANVAS_W = VIEW_W_TILES * TILE;
const CANVAS_H = VIEW_H_TILES * TILE;
const canvas = document.getElementById('c');
canvas.width = CANVAS_W; canvas.height = CANVAS_H;
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// UI
const hpText = document.getElementById('hpText');
const runCountText = document.getElementById('runCount');
const confirmBtn = document.getElementById('confirmBtn');
const invBtn = document.getElementById('invBtn');
const invModal = document.getElementById('invModal');
const invGrid = document.getElementById('invGrid');
const closeInv = document.getElementById('closeInv');

const joystickBase = document.getElementById('joystickBase');
const joystickKnob = document.getElementById('joystickKnob');

let mapData = null;

// state
let state = {
  player: { x: 4, y: 7, tx:4, ty:7, moving:false, hp:30, maxHp:30 },
  inventory: { seed_wheat:5, trap_egg:1 },
  party: [],
  time: { runCount:0 }
};

// util
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;

// load map json
async function loadMap(){
  try{
    const res = await fetch('assets/map.json');
    if(!res.ok) throw new Error('map.json load failed');
    mapData = await res.json();
    // if map smaller/bigger than canvas, we assume mapData.width/height == VIEW_W_TILES
    // build tile->region reverse index
    buildRegionTiles();
    // start loop
    requestAnimationFrame(step);
  }catch(e){
    alert('マップ読み込みに失敗しました: ' + e.message + '\n(HTTP サーバー経由で開いてください)');
  }
}

// build region tiles list
function buildRegionTiles(){
  if(!mapData) return;
  mapData._tiles = Array.from({length: mapData.height}, ()=>Array(mapData.width).fill(null));
  mapData.regions.forEach(region=>{
    for(let yy=0;yy<region.h;yy++){
      for(let xx=0;xx<region.w;xx++){
        const gx = region.x + xx, gy = region.y + yy;
        if(gx>=0 && gx<mapData.width && gy>=0 && gy<mapData.height){
          mapData._tiles[gy][gx] = region.id;
        }
      }
    }
  });
}

// draw main map
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background
  for(let y=0;y<mapData.height;y++){
    for(let x=0;x<mapData.width;x++){
      const regionId = mapData._tiles[y][x];
      if(regionId){
        const r = mapData.regions.find(rr=>rr.id===regionId);
        if(r.type === 'farm') ctx.fillStyle = '#2c7b34';
        else if(r.type === 'dungeon') ctx.fillStyle = '#6b4f3a';
        else ctx.fillStyle = '#446';
      } else {
        ctx.fillStyle = '#274a2b';
      }
      ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.strokeRect(x*TILE,y*TILE,TILE,TILE);
    }
  }

  // draw region outlines and names
  mapData.regions.forEach(r=>{
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1.2;
    ctx.strokeRect(r.x*TILE + 1, r.y*TILE + 1, r.w*TILE -2, r.h*TILE -2);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '10px sans-serif';
    ctx.fillText(r.name, r.x*TILE + 4, r.y*TILE + 12);
  });

  // entities (player)
  // small shadow
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(state.player.x*TILE+4, state.player.y*TILE+10, TILE-8, 4);
  // player square
  ctx.fillStyle = '#4db3ff';
  ctx.fillRect(state.player.x*TILE+2, state.player.y*TILE+2, TILE-4, TILE-4);
}

// movement & input (joystick)
let desiredDir = {x:0,y:0}; // includes strength (-1..1)
const MOVE_SPEED = 6.0;
function clientPointFromEvent(e){ if(e.touches && e.touches.length>0) return {x:e.touches[0].clientX, y:e.touches[0].clientY}; if(e.clientX!==undefined) return {x:e.clientX, y:e.clientY}; return null; }
function pointInJoystickBase(pt){ const r = joystickBase.getBoundingClientRect(); return pt.x>=r.left && pt.x<=r.right && pt.y>=r.top && pt.y<=r.bottom; }

function handleClientPoint(pt){
  const baseRect = joystickBase.getBoundingClientRect();
  if(pointInJoystickBase(pt)){
    const centerX = baseRect.left + baseRect.width/2;
    const centerY = baseRect.top + baseRect.height/2;
    let dx = pt.x - centerX, dy = pt.y - centerY;
    const maxR = Math.min(baseRect.width, baseRect.height) * 0.42;
    const dist = Math.hypot(dx,dy);
    let strength = Math.min(dist / maxR, 1.0);
    if(dist > 0.001){
      dx /= dist; dy /= dist;
      desiredDir.x = dx * strength; desiredDir.y = dy * strength;
    } else { desiredDir.x = 0; desiredDir.y = 0; }
    if(Math.hypot(desiredDir.x, desiredDir.y) < 0.12){ desiredDir.x = 0; desiredDir.y = 0; }
  } else {
    // outside joystick: treat as action tap on canvas
    const rect = canvas.getBoundingClientRect();
    if(pt.x < rect.left || pt.x > rect.right || pt.y < rect.top || pt.y > rect.bottom) return;
    const cx = pt.x - rect.left, cy = pt.y - rect.top;
    handleActionAtScreen(cx, cy, rect);
  }
}

// canvas handlers
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); const p=clientPointFromEvent(e); if(p) handleClientPoint(p); }, {passive:false});
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); const p=clientPointFromEvent(e); if(p) handleClientPoint(p); }, {passive:false});
canvas.addEventListener('touchend', e=>{ desiredDir.x = 0; desiredDir.y = 0; }, {passive:false});
canvas.addEventListener('mousedown', e=>{ const p=clientPointFromEvent(e); if(p) handleClientPoint(p); });
canvas.addEventListener('mousemove', e=>{ if(e.buttons){ const p=clientPointFromEvent(e); if(p) handleClientPoint(p); } });
canvas.addEventListener('mouseup', e=>{ desiredDir.x = 0; desiredDir.y = 0; });

// joystick visual & overlay handling (drag on visible base)
let joystickActive=false;
joystickBase.addEventListener('touchstart', e=>{ e.preventDefault(); joystickActive=true; const p=clientPointFromEvent(e); if(p) handleClientPoint(p); }, {passive:false});
joystickBase.addEventListener('touchmove', e=>{ e.preventDefault(); const p=clientPointFromEvent(e); if(p) handleClientPoint(p); }, {passive:false});
joystickBase.addEventListener('touchend', e=>{ e.preventDefault(); joystickActive=false; desiredDir.x=0; desiredDir.y=0; }, {passive:false});
joystickBase.addEventListener('mousedown', e=>{ e.preventDefault(); joystickActive=true; const p=clientPointFromEvent(e); if(p) handleClientPoint(p); });
window.addEventListener('mousemove', e=>{ if(!joystickActive) return; const p=clientPointFromEvent(e); if(p) handleClientPoint(p); });
window.addEventListener('mouseup', e=>{ if(joystickActive){ joystickActive=false; desiredDir.x=0; desiredDir.y=0; } });

// movement attempt (discrete tile grid)
function tryStartMove(){
  if(state.player.moving) return;
  const dx = desiredDir.x, dy = desiredDir.y;
  if(Math.hypot(dx,dy) < 0.35) return;
  let mx = 0, my = 0;
  if(Math.abs(dx) > Math.abs(dy)) mx = dx > 0 ? 1 : -1;
  else my = dy > 0 ? 1 : -1;
  const fromX = Math.floor(state.player.x), fromY = Math.floor(state.player.y);
  const tx = clamp(fromX + mx, 0, mapData.width-1);
  const ty = clamp(fromY + my, 0, mapData.height-1);
  // check passable: forbids leaving map
  state.player.tx = tx; state.player.ty = ty; state.player.moving = true;
}

// action tap on canvas (plant/inspect) — for main screen we'll use a simple info popup
function handleActionAtScreen(cx,cy,rect){
  const tx = Math.floor((cx/rect.width) * mapData.width);
  const ty = Math.floor((cy/rect.height) * mapData.height);
  const regionId = mapData._tiles[ty][tx];
  if(regionId){
    const region = mapData.regions.find(r=>r.id===regionId);
    alert('この領域: ' + region.name + ' (' + region.type + ')');
  } else {
    alert('空き地です');
  }
}

// Confirm behavior: if player adjacent to any tile of region, enter it
function confirmAction(){
  if(!mapData) return;
  // find adjacent regions
  const px = Math.floor(state.player.x), py = Math.floor(state.player.y);
  const adj = [];
  for(const r of mapData.regions){
    // check if any tile of region is adjacent (manhattan dist 1)
    for(let yy=r.y; yy<r.y + r.h; yy++){
      for(let xx=r.x; xx<r.x + r.w; xx++){
        const d = Math.abs(xx - px) + Math.abs(yy - py);
        if(d === 1) adj.push(r);
      }
    }
  }
  if(adj.length === 0){
    // nothing adjacent
    // optional: nearest region within distance 2?
    alert('近くに入れるエリアがありません。エリアに隣接して Confirm を押してください。');
    return;
  }
  // take first adjacent (or prefer dungeon over farm if both)
  let chosen = adj[0];
  const dgn = adj.find(a=>a.type==='dungeon');
  if(dgn) chosen = dgn;
  enterRegion(chosen);
}

// region entry handlers
function enterRegion(region){
  if(region.type === 'farm'){
    // for now just show a message; later replace with farm UI / overlay
    alert('拠点へ入ります: ' + region.name);
    // TODO: open farm overlay / zoom in / farm UI
  } else if(region.type === 'dungeon'){
    // navigate to dungeon page with query params
    const seed = Date.now();
    window.location.href = `dungeon.html?region=${encodeURIComponent(region.id)}&seed=${seed}`;
  } else {
    alert('Enter region: ' + region.name);
  }
}

// confirm button binding
confirmBtn.addEventListener('click', e=>{ e.preventDefault(); confirmAction(); });
// inventory
invBtn.addEventListener('click', e=>{ e.preventDefault(); openInventory(); });
closeInv.addEventListener('click', e=>{ invModal.style.display='none'; invModal.setAttribute('aria-hidden','true'); });
function openInventory(){
  invGrid.innerHTML = '';
  for(const k in state.inventory){
    const node = document.createElement('div');
    node.className = 'invSlot';
    node.textContent = `${k.replace('seed_','seed ')} x${state.inventory[k]}`;
    invGrid.appendChild(node);
  }
  invModal.style.display='block';
  invModal.setAttribute('aria-hidden','false');
}

// game loop
let lastTime = performance.now();
function step(now){
  const dt = (now - lastTime)/1000; lastTime = now;
  tryStartMove();
  if(state.player.moving){
    const tx = state.player.tx, ty = state.player.ty;
    const speed = MOVE_SPEED * dt;
    const dx = tx - state.player.x, dy = ty - state.player.y;
    const dist = Math.hypot(dx,dy);
    if(dist <= speed || dist < 0.001){
      state.player.x = tx; state.player.y = ty; state.player.moving = false;
    } else {
      state.player.x += (dx/dist)*speed;
      state.player.y += (dy/dist)*speed;
    }
  }

  updateUI();
  draw();
  updateJoystickVisual();
  requestAnimationFrame(step);
}

function updateUI(){
  hpText.textContent = `${Math.round(state.player.hp)}/${state.player.maxHp}`;
  runCountText.textContent = state.time.runCount;
}

// joystick visual
function updateJoystickVisual(){
  const baseRect = joystickBase.getBoundingClientRect();
  const maxOffset = Math.min(baseRect.width, baseRect.height) * 0.36;
  const offsetX = desiredDir.x * maxOffset;
  const offsetY = desiredDir.y * maxOffset;
  joystickKnob.style.left = `${50 + (offsetX / baseRect.width * 100)}%`;
  joystickKnob.style.top  = `${50 + (offsetY / baseRect.height * 100)}%`;
}

// helpers for findMonster etc (not used on main screen but kept for parity)
function findMonsterAt(x,y){ return null; }
function attemptCapture(){}

// start
loadMap();
</script>
</body>
</html>
